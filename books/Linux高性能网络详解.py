# Linux高性能网络详解：从DPDK、RDMA到XDP

第1部分　背景知识
  第1章　计算机网络概述 3
    1.1　计算机网络的定义和构成 3
    1.2　计算机网络的体系结构 4
    1.3　常见术语 6
  第2章　计算机硬件 10
    2.1　中央处理器 10
      2.1.1　处理器体系结构 11
      2.1.2　Cache 12
      2.1.3　NUMA 17
    2.2　存储器 19
    2.3　总线 19
    2.4　网卡 22
  第3章　Linux操作系统 25
    3.1　Linux操作系统的诞生和发展 25
    3.2　用户态和内核态 27
    3.3　虚拟地址、物理地址和页表 28
    3.4　用户空间和内核空间 30
    3.5　Linux内核的组成 31
      3.5.1　Linux内核源代码的目录结构 31
      3.5.2　Linux内核的主要组成部分 32
    3.6　Linux设备驱动程序 35
  第4章　软件和硬件之间传递信息的方式 37
    4.1　寄存器 37
    4.2　数据缓存 38
    4.3　队列和描述符 39
    4.4　中断 43
    4.5　DMA 46
  第5章　内核协议栈方案及其存在的问题 47
    5.1　内核协议栈方案的工作过程 47
    5.2　内核协议栈方案的数据流 49
    5.3　内核协议栈方案的缺点 50
  第6章　Corundum------一个开源的基于FPGA的100G网卡方案 51
    6.1　Corundum方案简介 51
    6.2　Corundum的队列 54
    6.3　Corundum的Linux网络设备驱动程序解析 56
      6.3.1　驱动程序源码概览 57
      6.3.2　驱动程序的编译和使用 57
      6.3.3　驱动程序的加载和注册 58
      6.3.4　驱动程序和设备的匹配 59
      6.3.5　初始化阶段 60
      6.3.6　打开网络接口 72
      6.3.7　数据发送 75
      6.3.8　中断处理 81
      6.3.9　发送完成处理 85
      6.3.10　数据接收 89
第2部分 DPDK
  第7章　认识DPDK 97
    7.1　为什么需要DPDK 97
    7.2　DPDK体系结构 98
      7.2.1　核心组件 98
      7.2.2　轮询模式驱动 100
    7.3　一个典型的DPDK应用程序 102
  第8章　DPDK的内存管理 104
    8.1　影响数据包处理速度的内存问题 104
    8.2　大页 105
      8.2.1　在Linux系统中预留和配置大页 105
      8.2.2　DPDK的大页管理 106
    8.3　mempool 111
    8.4　通道和rank 113
    8.5　DPDK使用的内存管理技巧总结 114
  第9章　UIO------DPDK的基石 115
    9.1　UIO驱动程序的构成 115
    9.2　应用程序和UIO的交互方式 118
    9.3　UIO驱动程序的API 119
    9.4　DPDK如何使用UIO 120
  第10章　DPDK的基本使用方法 123
    10.1　编译DPDK 123
    10.2　使用dpdk-testpmd进行数据包转发测试 123
      10.2.1　运行环境和连接方式 124
      10.2.2　使用Linux以太网驱动程序运行dpdk-testpmd 125
      10.2.3　使用轮询模式驱动程序运行dpdk-testpmd 129
    10.3　使用pktgen测试Mellanox ConnectX-4 LX 10G网卡 132
      10.3.1　硬件环境 132
      10.3.2　软件版本 132
      10.3.3　安装Mellanox网卡驱动程序 132
      10.3.4　编译和安装DPDK 133
      10.3.5　"回环+转发"测试 133
      10.3.6　编译pktgen 138
      10.3.7　"外部发包+本地转发"测试 138
      10.3.8 测试过程中可能遇到的问题及解决方法 141
  第11章　测试和分析高性能网卡 142
    11.1　关于DDR访问速率的思考和测试 142
      11.1.1　硬件配置和软件版本 143
      11.1.2　DDR理论速率 144
      11.1.3　内存性能测试工具mbw 145
      11.1.4　单核测试 146
      11.1.5　多核测试 148
    11.2　基于100G网卡的单核和多核测试 150
      11.2.1　硬件配置 150
      11.2.2　软件版本和配置 150
      11.2.3　单核测试 150
      11.2.4　双核测试 152
      11.2.5　测试结果总结 153
    11.3　使用Intel VTune Profiler定量分析DPDK 154
      11.3.1　硬件环境和软件版本 154
      11.3.2　Intel VTune Profiler的下载和安装 155
      11.3.3　测试模型 155
      11.3.4　重新编译安装DPDK 155
      11.3.5　使用Intel VTune Profiler启动和监控dpdk-testpmd 156
      11.3.6　开始产生和发送数据包 159
      11.3.7　统计和分析 159
    第１2章　为Corundum编写DPDK驱动程序 163
    12.1　Corundum DPDK驱动程序的组成 164
    12.2　注册和打开调试日志 164
      12.2.1　DPDK的日志级别 164
      12.2.2　Corundum DPDK驱动程序的日志 165
    12.3　Corundum DPDK驱动程序的注册 167
    12.4　Corundum DPDK驱动程序的初始化 168
    12.5　启动队列 173
    12.6　数据发送 176
    12.7　编写驱动程序时的注意事项 179
第3部分　RDMA
  第13章　RDMA技术简介 185
    13.1　RDMA的控制通路和数据通路 185
    13.2　RDMA的优势 188
    13.3　RDMA协议 189
      13.3.1　InfiniBand 190
      13.3.2　RoCE 190
      13.3.3　iWARP 192
      13.4　RDMA网络构成 192
      13.5　LID和GID 194
      13.5.1　LID 194
      13.5.2　GID 195
  第14章　RDMA软件架构 198
    14.1　rdma-core 198
    14.2　内核RDMA子系统 199
    14.3　RDMA软件架构总览 201
  第15章　RDMA基本元素 202
    15.1　WQ和WQE 202
    15.2　QP和QPN 203
    15.3　CQ和CQN 205
    15.4　WR和WC 206
    15.5　RDMA基本元素总结 207
  第16章　RDMA基本操作类型及其配套机制 208
    16.1　Send和Receive 208
    16.2　RDMA Write 209
    16.3　RDMA Read 210
    16.4　其他RDMA操作类型 212
    16.5　RDMA操作类型总结 213
    16.6　Memory Region 214
      16.6.1　MR的基本概念 215
      16.6.2　MR的作用之一 215
      16.6.3　MR的作用之二 216
      16.6.4　MR的作用之三 217
    16.7　PD 218
    16.8　Doorbell机制 219
    16.9　RDMA各种元素的实体形式 220
  第17章　RDMA传输服务 222
    17.1　传输服务维度一------可靠/不可靠 222
    17.2　传输服务维度二------连接/数据报 223
    17.3　传输服务类型 225
  第18章　一个简单的RDMA应用程序 229
    18.1　程序的执行和输出 229
    18.2　代码执行流程 230
  第19章　RDMA主要元素的实现 234
    19.1　分配PD 234
    19.2　注册MR 240
      19.2.1　代码执行流程分析 240
      19.2.2　注册MR的具体工作 242
      19.2.3　硬件查表获取MR物理地址的过程 246
      19.2.4　MR相关的软硬件行为汇总 248
    19.3　创建CQ 249
      19.3.1　代码执行流程分析 249
      19.3.2　CQ buffer的组织形式 253
      19.3.3　CQ Context的组织形式 255
      19.3.4　硬件获取CQE地址的过程 257
      19.3.5　CQ相关的软硬件行为汇总 258
    19.4　创建QP 258
      19.4.1　代码执行流程分析 258
      19.4.2　QP buffer的组织形式 263
      19.4.3　QP Context的组织形式 264
    19.5　修改QP 265
      19.5.1　应用程序修改QP 265
      19.5.2　代码执行流程分析 267
      19.5.3　硬件获取WQE地址的过程 270
  第20章　进行一次数据传输 272
    20.1　发起数据传输------RDMA Write 272
      20.1.1　应用程序发起数据传输 272
      20.1.2　代码执行流程分析 273
    20.2　确认数据传输完毕------轮询CQ 276
    20.3　软件和硬件行为汇总 277
  第21章　RoCEv2网卡的MAC、IP和GID 279
    21.1　RoCEv2网卡的GID 279
    21.2　向RoCEv2网卡配置自己的MAC、IP和GID 281
      21.2.1　获取RoCEv2网卡自己的MAC 281
      21.2.2　获取RoCEv2网卡自己的IP地址 281
      21.2.3　配置RoCEv2网卡自己的0号GID 281
      21.2.4　配置RoCEv2网卡自己的非0号GID 282
    21.3　向RoCEv2网卡配置对端设备的MAC、IP和GID 282
      21.3.1　应用程序获取本地和对端设备的0号GID 283
      21.3.2　应用程序获取对端设备的非0号（3号）GID 284
      21.3.3　向RoCEv2网卡配置对端设备的MAC地址 284
      21.3.4　向RoCEv2网卡配置对端设备的IP地址 285
  第22章　RDMA性能测试工具---perftest 286
    22.1　源码获取和安装 286
    22.2　测试方法和注意事项 286
    22.3　测试选项 287
    22.4　简单的测试过程和结果呈现 289
第4部分　XDP
  第23章　XDP简介 293
    23.1　什么是BPF和eBPF 293
    23.2　XDP系统架构 294
      23.2.1　XDP程序的执行流程 295
      23.2.2　BPF map 297
  第24章　XDP教程代码分析 298
    24.1　xdp-tutorial代码获取和编译 298
    24.2　基础课程 299
      24.2.1　XDP程序的加载和卸载 299
      24.2.2　按名称加载SEC 301
      24.2.3　使用BPF map 302
      24.2.4　多程序交流和共享 304
    24.3　数据包处理课程 308
      24.3.1　解析数据包 308
      24.3.2　改写数据包 311
      24.3.3　重定向 313
  第25章　简单的XDP性能测试 319
    25.1　测试方法 319
    25.2　测试流程和命令 320
    25.3　测试结果 321
    25.4　测试结果分析 321
  第26章　让网卡驱动程序支持XDP功能 322
    26.1　XDP代码在网卡驱动中的位置 322
    26.2　数据包的准备 323
    26.3　返回值的处理 323
附录A　在Linux系统中查找各种核的对应关系 325
附录B　关于内存性能测试工具mbw的问题分析 331
附录C　简单分析memcpy的代码优化方法 335
附录D　用线性回归方法计算CPU频率 338
